\clearpage
\setcounter{page}{1}

\section{FEM mit Stabelementen}



\subsection{Elementsteifigkeitsmatrix\label{subsec:stabke}}

Betrachtet wird das Fachwerk aus Aufgabe 4.1.\medskip

\begin{minipage}[b]{0.4\textwidth}
  \input{fig/ue5_fachwerk1.pdf_tex}
%   \captionof{figure}{}
%   \label{fig:fachw1}
\end{minipage}
 \hfill
\begin{minipage}[b]{0.56\textwidth}
  \input{fig/ue4_fachwerk1_diskret.pdf_tex}
%   \captionof{figure}{Element- und Knotennummerierung}
%   \label{fig:fw1dis}
 \end{minipage}
 
\enab
 \item Wie lassen sich die Einträge der Elementsteifigkeitsmatrizen $\mk^e$ berechnen? \\
   Werten Sie auch die Spezialfälle $\alpha\in\{\pi / 2, 3\pi /2\} $ und $\alpha\in\{0,\pi\}$ aus.
 \item Schreiben Sie die \matl-Funktion {\tt PlaneTrussElementStiffness.m} zur Berechnung der Elementsteifigkeitsmatrizen. 
   Verwenden sie die Parameter aus Tabelle \ref{tab:inppte}
\enae

\textit{Hinweis:}
$\tt PlaneTrussElementStiffness.m$ ist eine Subroutine zur Berechnung der Elementsteifigkeitsmatrix im globalen Koordinatensystem.
Die Inputwerte sind E-Modul $\tt E$, Stabquerschnitt $\tt A$ und die Knotenkoordinaten $\tt i$ und $\tt j$ (vgl. Abbildung \ref{fig:ten083}).
\begin{verbatim} 
  node_i(1) = x(1) 
  node_i(2) = y(1)  
  node_j(1) = x(2) 
  node_j(2) = y(2)  
\end{verbatim} 

Outputgröße ist die Elementsteifigkeitsmatrix im globalen x,y-Koordinatensystem:
  \ebn
  \mk^\mrm{e} = \mT^T \; \tilde{\mk} {}^\mrm{e} \; \underline \bT
  \quad \text{mit} \quad 
  \tilde{\mk} {}^\mrm{e} = \int_{\B^\mrm{e}} (\mB^\mrm{e})^T EA \; \mB^{\mrm{e}} \; \mrm{d} \tilde{x }
  \een
%\medskip

\begin{minipage}[b]{0.46\textwidth}
   \scalebox{0.8}{\input{fig/ue5_ten083.pdf_t}}
%   \setlength{\baselineskip}{11pt} 
  \captionof{figure}{}%Knotenkoordinaten in {\tt PlaneTrussElementStiffness.m}}
  \label{fig:ten083}
\end{minipage}
 \hfill
%  \begin{figure}[htb] \unitlength 1 cm
\begin{minipage}[b]{0.46\textwidth}
 \begin{tabular}{ll}
  \multicolumn{2}{c}{Inputparameter}\\
\toprule
\tt E & {\tt 10000} $\mrm{kN}/\mrm{m}^2$\\
\tt A & {\tt 0.02} $\mrm{m}^2$ \\
\tt node no.1: [ x y ] & \tt [ 0 0 ] $\mrm{m}$ \\
\tt node no.2: [ x y ] & \tt [ 1 2 ] $\mrm{m}$ \\
\tt node no.4: [ x y ] & \tt [ 3 2 ] $\mrm{m}$ \\
\midrule
\end{tabular}
\captionof{table}{}
\label{tab:inppte}
 \end{minipage}\medskip
%  \end{figure}

\enabres
 \item Bestimmen Sie den Lösungsvektor $\mD$ mithilfe des in der vorherigen Übung aufgestellten globalen Gleichungssystems. 
 Die Kräfte betragen $F_x = 0.01\,\mrm{kN}$ und $F_y = -0.05\, \mrm{kN}$.
\enae




\subsection{Schreiben eines FEM-Programms}

Im Folgenden soll ein eigener FE-Code in \matl\ erzeugt werden, mithilfe dessen die Knotenverschiebungen von ebenen Fachwerken berechnet werden können.
Der Workflow des Programms kann Abbildung \ref{fig:workfl} entnommen werden.
Dabei stellt die Datei $\tt PlaneTruss.m$ die Hauptdatei dar. 
Mit ihr werden zunächst Element- und Knotendaten des Fachwerkes eingelesen.
Daraufhin werden mithilfe der Subroutinen $\tt PlaneTrussElementStiffness.m$ und $\tt PlaneTrussAssemble.m$ die Elementsteifigkeitsmatrizen aufgestellt und im globalen Gleichungssystem assembliert.
Schließlich wird der globale Lastvektor aufgestellt und das globale Gleichungssystem gelöst.\medskip

% programmcode workflow
%----------------------------------------
\begin{figure}[htb]
\unitlength1cm
\fboxsep2mm
\begin{picture}(15,15)(0,-14.5)
  \put(7.5,  0){\vector(0,-1){1}}
  \put(7.5,  0){\makebox[0mm]{\fcolorbox{black}{white}{read general properties}}}
  \put(7.5, -1.5){\vector(0,-1){1}}
  \put(7.5, -1.5){\makebox[0mm]{\fcolorbox{black}{white}{nodes, coordinates and stiffnes ($E$ and $A$)}}}
  \put(7.5, -3){\vector(0,-1){1}}
  \put(7.5, -3){\makebox[0mm]{\fcolorbox{black}{white}{compute number of equations}}}
  \put(7.5, -4.5){\vector(0,-1){1.0}}
  \put(7.5, -5.5){\circle*{0.1}}
  \put(7.5, -5.5){\vector(0,-1){0.75}}
  \put(7.5, -4.5){\makebox[0mm]{\fcolorbox{black}{white}{complete assemble matrix}}}
  \put(7.5, -6.75){\vector(0,-1){1}}
  \put(7.5, -6.75){\makebox[0mm]{\fcolorbox{black}{white}{compute local element stiffness $\underline \bk^e$}}}
  \put(11, -6.75){$\rightarrow$ \tt PlaneTrussElementStiffness.m}
  \put(7.5, -8.65){\vector(0,-1){1.5}}
  \put(7.5,-10.15){\circle*{0.1}}
  \put(7.5,-10.15){\vector(0,-1){0.75}}
  \put(7.5, -8.65){\makebox[0mm]{\fcolorbox{black}{white}{assemble global stiffness matrix
$\underline \bK = \Assem \; \underline \bk^e $}}}
  \put(12, -8.65){$\rightarrow$ \tt PlaneTrussAssemble.m}
  \put(7.5,-11.4){\vector(0,-1){1}}
  \put(7.5,-11.4){\makebox[0mm]{\fcolorbox{black}{white}{complete global force vector (interactive)}}}
  \put(7.5,-12.9){\vector(0,-1){1}}
  \put(7.5,-12.9){\makebox[0mm]{\fcolorbox{black}{white}{solve system of equations to compute displacements}}}
  \put(7.5,-14.4){\makebox[0mm]{\fcolorbox{black}{white}{postprocess (print data)}}}
  
  \put(2.5, -5.5){\vector(1,0){5}}
  \put(2.5, -5.5){\line(0,-1){4.65}}
  \put(2.5,-10.15){\line(1,0){5}}

  \put(7.7,-5.6){begin loop over elements $e$}
  \put(7.7,-10.25){end loop if $e > nele$}

\end{picture}\medskip
\caption{Workflow von $\tt PlaneTruss.m$ }
\label{fig:workfl}
\end{figure}

% inputdata
%-----------------------------------------------
\clearpage
\enab
 \item Erzeugen sie zunächst in der Hauptdatei {\tt PlaneTruss.m} ein Interface, mit welchem die Element- und Knotendaten sowie die Dirichlet-Randbedingungen eingelesen werden.
\enae

\textit{Hinweis:} 
Anhand des einfachen Fachwerks in Abbildung \ref{fig:ten086} soll veranschaulicht werden wie die entsprechenden Daten eingelesen und abgespeichert werden.

\begin{figure}[htb] \unitlength 1 cm
\begin{picture}(14,4.0)%
 \put(0.0,-0.3){\scalebox{0.8}{\input{fig/ue5_ten086.pdf_t}}}
 \put(6.4,0.3){\scalebox{0.8}{\input{fig/ue5_ten087.pdf_t}}}
\put(0.0,0.0){a)}
\put(6.4,0.0){b)}
\end{picture}
% \setlength{\baselineskip}{11pt} 
\medskip
\caption{Fachwerk: 
a) Dimension (in Metern) und Randbedingungen,
b) Diskretisierung.}
\label{fig:ten086}
\end{figure}

Nach dem Programmstart soll zunächst folgender Input erfolgen:

{\small 
\begin{verbatim}
>> PlaneTruss
give the total number of elements. num_ele = 2
give the total number of nodes.  num_nodes = 3
\end{verbatim}}

Im nächsten Schritt wird die Matrix $\tt connectivity$ erstellt.
In ihr wird abgespeichert, welche globale Knotennummer zu welchem element gehört. 
Sie hat die Dimension $ \left[\, \tt nodes\_ele \times \tt num\_ele\, \right] $, wobei $\tt nodes\_ele=2$ die Anzahl der Knoten je Element darstellt.
In diesem Beispiel besitzt Element 1 die globalen Knoten 1 und 2; Element 2 hat die Knoten 2 und 3.
Die $\tt connectivity$-Matrix sieht wie folgt aus:

\ebn
\tt
connectivity = \begin{bmatrix}
                  1 & 2 \\
                  2 & 3
                 \end{bmatrix}
\label{eq:conne1}
\een

Der E-Modul sei mit 
$
 \rm
 E = 10 000 \, kN/m^2
 $
festgelegt und die Querschnittsfläche der Elemente 1 und 2 sei
\ebn
 \rm
 0.02 \, m^2 \quad und \quad 0.015 \, m^2.
 \een
 
Die Elementdaten werden nun wie folgt eingegeben

{\small 
\begin{verbatim}
element no.1
  global node for 1st local node = 1
  global node for 2nd local node = 2
  element data           [ E A ] = [10000 0.02]
 
element no.2
  global node for 1st local node = 2
  global node for 2nd local node = 3
  element data           [ E A ] = [10000 0.015],
\end{verbatim}}

wobei die eingegebenen Knotennummern in der $\tt connectivity$-Matrix gespeichert werden.\medskip

Nun werden für alle Knoten die ($\rm x,y$)-Koordinaten eingegeben
Die entsprechende $\tt X$-Matrix der Knotenkoordinaten  der Dimension  $ \left[\, \tt dof\_nodes \times \tt num\_nodes\, \right] $ lautet:

\ebn
\tt
X = \begin{bmatrix}
                  0 & 2 & 4\\
                  0 & 2 & 2
                 \end{bmatrix}
\label{eq:Xmatr1}
\een

Der Input sieht wie folgt aus:

 
{\small 
\begin{verbatim}
node no.1
  global node coordinates [ x y ] = [0 0]
 
node no.2
  global node coordinates [ x y ] = [2 2]
 
node no.3
  global node coordinates [ x y ] = [4 2]
\end{verbatim}}
 
Die Anzahl an Dirichlet-Randbedingungen $\tt num\_bc$ beträgt 4. 
Nach der Eingabe 
\begin{verbatim}
 give the total number of displacement boundary conditions
                                        num_bc = 4
\end{verbatim}


kann nun die Anzahl an verbleibenden Freiheitsgraden mit
\eb
\tt num\_eq= num\_nodes * dof\_nodes - num\_bc
\label{eq:numeq}
\ee 
bestimmt werden.
Die Horizontal- und Vertikalverschiebungen der Knoten 1 und 3 werden auf Null gesetzt:
\ebn
\rm
d^{\nodeid 1}_1 = d^{\nodeid 1}_2 = d^{\nodeid 3}_1 = d^{\nodeid 3}_2 = 0,
\een 
bzw.
\ebn
\rm
D_1 = D_2 = D_5 = D_6 = 0.
\een 

Im Zusammenhang mit diesem Schritt wird die Matrix $\tt assembleid$ erstellt. 
Sie hat die Dimension $ \left[\, \tt dof\_nodes \times \tt num\_nodes\, \right] $ und beinhaltet alle verbleibenden Freiheitsgrade.
An den Positionen, an denen Dirichlet-Randbedingungen vorliegen, befinden sich Nulleinträge. 
Für das Beispiel lautet sie also:

\ebn
\tt
assembleid = \begin{bmatrix}
                  0 & 1 & 0\\
                  0 & 2 & 0
                 \end{bmatrix}
\label{eq:asmat1}
\een


Die Inputsequenz dazu lautet:
{\small 
\begin{verbatim}
    input of global dofs with zero boundary displacements
                                   for i from 1 to num_bc
        global node of constrained degree of freedom = 1
          degree of freedom to constrained (1=x,2=y) = 1
        global node of constrained degree of freedom = 1
          degree of freedom to constrained (1=x,2=y) = 2
        global node of constrained degree of freedom = 3
          degree of freedom to constrained (1=x,2=y) = 1
        global node of constrained degree of freedom = 3
          degree of freedom to constrained (1=x,2=y) = 2
\end{verbatim}}



% assemblierung
%-----------------------------------------------
\enabres
\item Setzen Sie die Assemblierung der Elementsteifigkeitsmatrizen zur globalen Steifigkeitsmatrix algorithmisch in Form von \matl\ Code in der Hauptdatei $\tt PlaneTruss.m$ und mithilfe der Subroutinen $\tt PlaneTrussElementStiffness.m$ und $\tt PlaneTrussAssemble.m$ um.
\enae

\textit{Hinweis:}
Die Assemblierung findet in einer Schleife über die Elemente statt, in der für jedes Element zunächst die lokale Steifigkeitsmatrix $\mk^e$ (mithilfe von $\tt PlaneTrussElementStiffness.m$) erzeugt wird.
Mithilfe der Subroutine $\tt PlaneTrussAssemble.m$ soll die globale Steifigkeitsmatrix nun an den passenden Einträgen mit den jeweiligen Einträgen der lokalen Steifigkeitsmatrix besetzt werden. 
Um diesen Prozess zu veranschaulichen wird das Fachwerk in Abbildung \ref{fig:ten078} betrachtet

\begin{figure}[htb] \unitlength 1 cm
\begin{picture}(14,3.0)%
\put(0.5,0){\scalebox{0.8}{\input{fig/ue5_ten078.pdf_t}}}
\end{picture}
\setlength{\baselineskip}{11pt} 
\caption{}
\label{fig:ten078}
\end{figure}

Die $\tt connectivity$-Matrix lautet:

\ebn
\tt
connectivity = \begin{bmatrix}
                 1 & 3 & 1 & 2 & 3 & 4 & 5 & 2 & 4 \\
                 3 & 5 & 2 & 3 & 4 & 5 & 6 & 4 & 6
                 \end{bmatrix}
\een

Das Randwertproblem besteht aus neun Stabelementen, sechs Knoten und vier essentiellen Randbedingungen, d.h. 
 \ebn 
\tt num\_ele = 9  ,\quad num\_nodes = 6  ,  \quad num\_bc = 4  .
\een

Die Elementsteifigkeitsmatrix $\bk^e$ hat die Dimension $\left[\,\tt k^e_{dim} \times k^e_{dim} \right]$ mit

\ebn
\tt k^e_{dim}=nodes\_ele * dof\_nodes = 4.
\een

Die Dimension der globalen Steifigkeitsmatrix $\mK$ unter Berücksichtigung der Dirichlet Randbedingungen ist  $\left[\,\tt num\_eq \times num\_eq \right]$ mit $\tt num\_eq=8$ \eqref{eq:numeq}.
Die $\tt assembleid$-Matrix lautet

\ebn
\tt
assembleid = \begin{bmatrix}
                  1 & 2 & 4 & 6 & 8 & 0\\
                  0 & 3 & 5 & 7 & 0 & 0
                 \end{bmatrix}.
\een

Mit ihrer Hilfe werden die einzelnen Einträge $[\bk^e]_{\mrm{ij}}$ der Elementsteifigkeitsmatrix den Einträgen $[\bK]_{\mrm{IJ}}$ der globalen Steifigkeitsmatrix zugeordnet.
Bevor dies geschieht wird jedoch zunächst die leere globale Steifigkeitsmatrix aufgestellt mit 

\ebn
\rm
K_{IJ} = 0.0 \quad \text{für} \quad I,J = 1,...8 \;.
\een

Nun wird der Element-Schleifendurchlauf gestartet.
In jedem Iterationsschrit wird zunächst die lokale Elementsteifigkeitsmatrix $\mk^e$ mit $\tt PlaneTrussElementStiffness.m$ erzeugt.
Daraufhin wird mithilfe der Subroutine $\tt PlaneTrussAssemble.m$ die globale Steifigkeitsmatrix $\mK$ geupdatet.
Um diesen Vorgang zu verdeutlichen wird der erste Iterationsschritt (Element $e=1$) betrachtet. 
Die Positionen $\mrm{I}$ und $\mrm{J}$ in der globalen Matrix können den Einträgen der $\tt connectivity$- und $\tt assembleid$- Matrix entnommen werden:
%
\begin{align*}
 \mrm{I} &= \tt assembleid(:,connectivity(1,1))= [\ 1\ \ 0\ ]  \\
 \mrm{J} &= \tt assembleid(:,connectivity(1,2))= [\ 4\ \ 5\  ]
\end{align*}
%
mit der Elementsteifigkeitsmatrix

\ebn
\rm
\renewcommand{\arraystretch}{1.5}
\begin{array}{rrccccl|l}
 & & 1 & 0 & 4 & 5 & & \mbox{global dof}\\\cline{2-8}
%
& \multirow{4}{2mm}{$\renewcommand{\arraycolsep}{0mm}\left[\begin{array}{r}
\phantom{1}\\\phantom{1}\\\phantom{1}\\\phantom{1}
\end{array}\right.$}
& \rm k^{\elemid 1}_{11} & \rm k^{\elemid 1}_{12} & \rm k^{\elemid 1}_{13} & \rm k^{\elemid 1}_{14} &
\multirow{4}{2mm}{\hspace*{-7mm}$\left.\begin{array}{l}
\phantom{1}\\\phantom{1}\\\phantom{1}\\\phantom{1}
\end{array}\right]$}
& \rule{0mm}{3.5ex}1\\
%
\multirow{2}*{$\underline \bk^{\elemid 1} =$}  & & \rm k^{\elemid 1}_{21} & \rm k^{\elemid 1}_{22} & \rm k^{\elemid 1}_{23} & \rm k^{\elemid 1}_{24} && 0 \\
%
& & \rm k^{\elemid 1}_{31} & \rm k^{\elemid 1}_{32} & \rm k^{\elemid 1}_{33} & \rm k^{\elemid 1}_{34} && 4\\
%
& & \rm k^{\elemid 1}_{41}  & \rm k^{\elemid 1}_{42} & \rm k^{\elemid 1}_{43} & \rm k^{\elemid 1}_{44} && 5 
\end{array} .
\een

Die ersten zwei Zeilen und Spalten von $\rm \underline \bk^{\elemid 1}$ sind dem vertikalen und horizontalem Freiheitsgrad des globalen Knotens 1 zugeornet;
die dritte und vierte Zeile und Spalte sind dem globalen Knoten 3 zugeordnet.
Mit der dieser Information folgt nun der Update-Vorgang

\eb
\renewcommand{\arraystretch}{1.5}
\begin{array}{r@{\Longleftarrow}l@{\hspace{4ex}}r@{\Longleftarrow}l@{\hspace{4ex}}r@{\Longleftarrow}l}
\rm K_{11} & K_{11} + k^{\elemid 1}_{11}\,, & \rm K_{14} & K_{14} + k^{\elemid 1}_{13}\,, & \rm K_{15} & K_{15} + k^{\elemid 1}_{14}\,, \\
%
\rm K_{41} & K_{41} + k^{\elemid 1}_{31}\,, & \rm K_{44} & K_{44} + k^{\elemid 1}_{33}\,, & \rm K_{45} & K_{45} + k^{\elemid 1}_{43}\,, \\
%
\rm K_{51} & K_{51} + k^{\elemid 1}_{41}\,, & \rm K_{54} & K_{54} + k^{\elemid 1}_{34}\,, & \rm K_{55} & K_{55} + k^{\elemid 1}_{44}\,.
\end{array}
\label{eq:updat1}
\ee

Es wird deutlich, dass die Einträge der zweiten Zeile und Spalte nicht in das Update der globalen Matrix eingehen, da die zugehörigen globalen Freiheitsgrade aufgrund der Dirichlet-Randbedingungen in der $\tt assembleid$-Matrix mit  Null gekennzeichnet sind.
Für den zweiten Iterationsschritt $e=2$, bei dem das zweite Element betrachtet wird, folgt:

\ebn
\rm
\renewcommand{\arraystretch}{1.5}
\begin{array}{rrccccl|l}
 & & 4 & 5 & 8 & 0 & & \mbox{global dof}\\\cline{2-8}
%
& \multirow{4}{2mm}{$\renewcommand{\arraycolsep}{0mm}\left[\begin{array}{r}
\phantom{1}\\\phantom{1}\\\phantom{1}\\\phantom{1}
\end{array}\right.$}
& \rm k^{\elemid 2}_{11} & \rm k^{\elemid 2}_{12} & \rm k^{\elemid 2}_{13} & \rm k^{\elemid 2}_{14} &
\multirow{4}{2mm}{\hspace*{-7mm}$\left.\begin{array}{l}
\phantom{1}\\\phantom{1}\\\phantom{1}\\\phantom{1}
\end{array}\right]$}
& \rule{0mm}{3.5ex}4\\
%
\multirow{2}*{$\underline \bk^{\elemid 2} =$}  & & \rm k^{\elemid 1}_{21} & \rm k^{\elemid 2}_{22} & \rm k^{\elemid 2}_{23} & \rm k^{\elemid 2}_{24} && 5 \\
%
& & \rm k^{\elemid 2}_{31} & \rm k^{\elemid 2}_{32} & \rm k^{\elemid 2}_{33} & \rm k^{\elemid 1}_{34} && 8\\
%
& & \rm k^{\elemid 2}_{41}  & \rm k^{\elemid 2}_{42} & \rm k^{\elemid 2}_{43} & \rm k^{\elemid 1}_{44} && 0 
\end{array} .
\een

\eb
\renewcommand{\arraystretch}{1.5}
\begin{array}{r@{\Longleftarrow}l@{\hspace{4ex}}r@{\Longleftarrow}l@{\hspace{4ex}}r@{\Longleftarrow}l}
\rm K_{44} & K_{44} + k^{\elemid 2}_{11} \,, & \rm K_{45} & K_{45} + k^{\elemid 2}_{12} \,, & \rm K_{48} & K_{48} + k^{\elemid 2}_{13} \,,\\
%
\rm K_{54} & K_{54} + k^{\elemid 2}_{21} \,, & \rm K_{55} & K_{55} + k^{\elemid 2}_{22} \,, & \rm K_{58} & K_{58} + k^{\elemid 2}_{23} \,,\\
% 
\rm K_{84} & K_{84} + k^{\elemid 2}_{31} \,, & \rm K_{85} & K_{85} + k^{\elemid 2}_{32} \,, & \rm K_{88} & K_{88} + k^{\elemid 2}_{33} \,.
\end{array}
\label{eq:updat2}
\ee

In gleicher Weise wird für die weiteren Elemente verfahren bis der Schleifendurchlauf über alle Elemente abgeschlossen ist.
Schließlich bleibt noch zu berücksichtigen, dass ein Element je nach vorliegenden Dirichlet Randbedingungen eine unterschiedliche Anzahl von Freiheitsgraden aufweisen kann.
Um diese Tatsache algorithmisch zu handhaben kann die Subroutine $\tt PlaneTrussAssemble.m$ als Kontrollroutine betrachtet werden welche mithilfe von Fallunterscheidung prüft wieviele aktive Freiheitsgrade im jeweiligen Element vorliegen.
Besitzt ein Element nur einen aktiven Freiheitsgrad so wird zum Update der globalen Steifigkeitsmatrix die Unterfunktion $\tt Assemble1.m$ aufgerufen.
Liegen zwei aktive Freiheitsgrade vor wird die Unterfunktion $\tt Assemble2.m$ aufgerufen, und so weiter.
In den Unterfunktionen selbst wird dann das Update, wie in \eqref{eq:updat1} und \eqref{eq:updat2} veranschaulicht, durchgeführt



% load vector, solve and print output
%----------------------------------------
\enabres
\item Versehen Sie die Hauptdatei $\tt PlaneTruss.m$ nun mit einem Interface, welches den globalen Lastvektor (Neumann-Randbedingungen) einliest.
\item Lassen Sie das Programm schließlich das globale Gleichungssystem lösen und die $\tt connectivity$-Matrix, $\mK,\mR$ und $\mD$ ausgeben.
\enae

\textit{Hinweis:}
Zum Verdeutlichen des Einlesevorgangs des Lastvektors $\tt R$ ($\left[ \tt num\_eq \times 1 \right]$) wird wieder das Beispiel aus Abbildung \ref{fig:ten086} betrachtet. 
Wie Abbildung \ref{fig:ten086} zu entnehmen ist, besteht dieser aus dem lokalen Vektor $\bF^{\nodeid 2}$, wofür folgende Werte gegeben seien:

\ebn
\rm
\bF^{\nodeid 2} = [F^{\nodeid 2}_1, F^{\nodeid 2}_2]^T = [0.01 \, kN, -0.05 \, kN]^T.
\een

Das Interface sieht folgendermaßen aus:
 %
{\small 
\begin{verbatim}
give the total number of nodes with non-zero load vectors
                                     num_loads = 1
             input of load vectors for i from 1 to num_loads
  no. of global node with non-zero load vector = 2
                   force in global x-direction = 0.01
                   force in global y-direction = -0.05
\end{verbatim}}

Der erste Output ist die zur $\tt connectivity$-Matrix gehörige Tabelle

 {
\small 
\begin{verbatim}
                 =============================
                 |  e  |  Node i  |  Node j  |
                 =============================
                 |  1  |     1    |     2    | 
                 |  2  |     2    |     3    | 
                 =============================
\end{verbatim}
}
Da $\mK,\mR$ und $\mD$ in dem Programm als Variablen auftreten kann der Output dieser Größen nach der Lösung direkt erfolgen. 

\enabres
 \item Verifizieren, ob ihr Programm richtig funktioniert, indem Sie Ihr FE-Programm für das Fachwerk aus \ref{subsec:stabke} auswerten und mit der Lösung von \ref{subsec:stabke}c) vergleichen.
\item Was passiert wenn Sie bei der Eingabe keine Lagerungsrandbedingungen angeben? 
  Wie lässt sich das beobachtete Verhalten begründen?
\enae



% 
% % Simple example for verification of the implementation
% 
% 
% % \subsection{}
% % 
% % Betrachtet wird das Fachwerk aus Aufgabe 4.2.\medskip
% % 
% % \begin{minipage}[b]{0.44\textwidth}
% %   \input{fig/ue4_fachwerk2.pdf_tex}
% % %   \captionof{figure}{Randwertproblem}
% % %   \label{fig:fachw2}
% % \end{minipage}
% % \hfill
% % \begin{minipage}[b]{0.5\textwidth}
% %    \input{fig/ue4_fachwerk2_diskret.pdf_tex}
% % %   \captionof{figure}{Diskretisierung}
% % %   \label{fig:fw2dis}
% %  \end{minipage}\medskip
% % 
% % Bestimmen Sie die Elementsteifigkeitsmatrizen $\bk^1$ und $\bk^3$.